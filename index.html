<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mahjong Solitaire</title>

<style>
body {
  font-family: system-ui, sans-serif;
  background:#f6f7fb;
  margin:0;
}

header {
  max-width:1200px;
  margin:20px auto;
  background:#fff;
  border-radius:14px;
  padding:16px;
}

.board-wrap {
  max-width:1200px;
  margin:0 auto 30px;
  background:#fff;
  border-radius:14px;
  padding:16px;
  overflow-x:auto;
}

.board {
  position:relative;
  width:1100px;
  height:650px;
}

.tile {
  position:absolute;
  width:82px;
  height:110px;
  background:#fff;
  border-radius:14px;
  border:2px solid #e5e7eb;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  box-shadow:
    3px 3px 0 #cfc6bb,
    6px 6px 0 #bfb5aa,
    0 6px 12px rgba(0,0,0,.25);
}

.tile svg {
  width:70%;
  height:70%;
}

.tile.free {
  box-shadow:
    0 0 0 8px rgba(42,123,111,.18),
    3px 3px 0 #cfc6bb,
    6px 6px 0 #bfb5aa;
}

.tile.blocked {
  opacity:.4;
  cursor:not-allowed;
}

.tile.hidden {
  visibility:hidden;
}

.tile.selected {
  outline:4px solid #2563eb;
}
</style>
</head>

<body>

<header>
  <h2>Mahjong Solitaire</h2>
  <p><span id="tilesLeft">144</span> tiles left · <span id="moves">0</span> moves</p>
</header>

<div class="board-wrap">
  <div class="board" id="board"></div>
</div>

<script>
const board = document.getElementById("board");
const tilesLeftEl = document.getElementById("tilesLeft");
const movesEl = document.getElementById("moves");

let tiles = [];
let selected = null;
let moves = 0;

/* === LAYOUT (144 tiles) === */
const layout = [];
for (let r=0;r<8;r++) for (let c=0;c<12;c++) layout.push({r,c,z:0});
for (let r=2;r<6;r++) for (let c=2;c<10;c++) layout.push({r,c,z:1});
for (let r=3;r<7;r++) for (let c=4;c<8;c++) layout.push({r,c,z:2});

/* === TILE VALUES === */
function buildValues() {
  const vals=[];
  for(let i=1;i<=9;i++) for(let j=0;j<4;j++) vals.push(`dots-${i}`);
  for(let i=1;i<=9;i++) for(let j=0;j<4;j++) vals.push(`bamboo-${i}`);
  for(let i=1;i<=9;i++) for(let j=0;j<4;j++) vals.push(`char-${i}`);
  ["E","S","W","N"].forEach(w=>{for(let i=0;i<4;i++) vals.push(`wind-${w}`)});
  ["R","G","W"].forEach(d=>{for(let i=0;i<4;i++) vals.push(`dragon-${d}`)});
  return vals.sort(()=>Math.random()-0.5);
}

/* === SVG TILE DRAWING === */
function tileSVG(type) {
  if(type.startsWith("dots")) {
    const n=+type.split("-")[1];
    return `<svg viewBox="0 0 100 100">
      ${Array.from({length:n}).map((_,i)=>
        `<circle cx="${20+(i%3)*30}" cy="${20+Math.floor(i/3)*30}" r="8" fill="#2563eb"/>`
      ).join("")}
    </svg>`;
  }

  if(type.startsWith("bamboo")) {
    const n=+type.split("-")[1];
    return `<svg viewBox="0 0 100 100">
      ${Array.from({length:n}).map((_,i)=>
        `<rect x="${20+(i%3)*25}" y="${15+Math.floor(i/3)*25}" width="8" height="20" fill="#15803d"/>`
      ).join("")}
    </svg>`;
  }

  if(type.startsWith("char")) {
    const n=type.split("-")[1];
    return `<svg viewBox="0 0 100 100">
      <text x="50" y="65" text-anchor="middle" font-size="48" fill="#b91c1c">萬</text>
      <text x="50" y="30" text-anchor="middle" font-size="20">${n}</text>
    </svg>`;
  }

  if(type.startsWith("wind")) {
    const w=type.split("-")[1];
    return `<svg viewBox="0 0 100 100">
      <text x="50" y="65" text-anchor="middle" font-size="48">${w}</text>
    </svg>`;
  }

  if(type.startsWith("dragon")) {
    const d=type.split("-")[1];
    const color=d==="R"?"#dc2626":d==="G"?"#15803d":"#374151";
    return `<svg viewBox="0 0 100 100">
      <text x="50" y="65" text-anchor="middle" font-size="48" fill="${color}">龍</text>
    </svg>`;
  }

  return "";
}

/* === GAME LOGIC (UNCHANGED) === */
function newGame() {
  board.innerHTML="";
  tiles=[];
  moves=0;
  selected=null;
  const values=buildValues();

  layout.forEach((p,i)=>{
    const t=document.createElement("div");
    t.className="tile";
    t.dataset.value=values[i];
    t.style.left=(p.c*88 + p.z*6)+"px";
    t.style.top=(p.r*116 - p.z*6)+"px";
    t.style.zIndex=p.z;
    t.innerHTML=tileSVG(values[i]);
    t.onclick=()=>clickTile(t);
    board.appendChild(t);
    tiles.push(t);
  });

  updateFree();
  updateStats();
}

function updateStats() {
  tilesLeftEl.textContent = tiles.filter(t=>!t.classList.contains("hidden")).length;
  movesEl.textContent = moves;
}

function isBlocked(tile) {
  const rect=tile.getBoundingClientRect();
  for(const t of tiles) {
    if(t===tile||t.classList.contains("hidden")||+t.style.zIndex<=+tile.style.zIndex) continue;
    const r=t.getBoundingClientRect();
    if(r.left<rect.right-10 && r.right>rect.left+10 &&
       r.top<rect.bottom-10 && r.bottom>rect.top+10) return true;
  }
  const left=tiles.some(t=>!t.classList.contains("hidden")&&
    t.style.zIndex===tile.style.zIndex&&
    t.style.top===tile.style.top&&
    parseInt(t.style.left)===parseInt(tile.style.left)-88);
  const right=tiles.some(t=>!t.classList.contains("hidden")&&
    t.style.zIndex===tile.style.zIndex&&
    t.style.top===tile.style.top&&
    parseInt(t.style.left)===parseInt(tile.style.left)+88);
  return left&&right;
}

function updateFree() {
  tiles.forEach(t=>{
    if(t.classList.contains("hidden")) return;
    t.classList.toggle("blocked",isBlocked(t));
    t.classList.toggle("free",!isBlocked(t));
  });
}

function clickTile(tile) {
  if(tile.classList.contains("blocked")) return;
  if(!selected){selected=tile;tile.classList.add("selected");return;}
  if(selected===tile){tile.classList.remove("selected");selected=null;return;}
  if(selected.dataset.value===tile.dataset.value){
    selected.classList.add("hidden");
    tile.classList.add("hidden");
    moves++;
  }
  selected.classList.remove("selected");
  selected=null;
  updateFree();
  updateStats();
}

setTimeout(newGame,50);
</script>

</body>
</html>
