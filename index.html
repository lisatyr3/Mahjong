<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mahjong Solitaire</title>

<style>
:root {
  --bg:#f6f7fb;
  --panel:#ffffff;
  --text:#142033;
  --border:#d9e0ea;
  --accent:#2a7b6f;
  --tileW:82px;
  --tileH:110px;
  --gap:6px;
}

body {
  margin:0;
  font-family:system-ui, sans-serif;
  background:var(--bg);
  color:var(--text);
}

body.large-tiles {
  --tileW:96px;
  --tileH:128px;
}

body.high-contrast {
  --bg:#0b1020;
  --panel:#0f172a;
  --text:#f8fafc;
}

.wrap {
  max-width:1200px;
  margin:20px auto;
  padding:0 14px;
}

header {
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:14px;
  padding:16px;
}

.top {
  display:flex;
  justify-content:space-between;
  flex-wrap:wrap;
  gap:12px;
}

.controls {
  margin-top:12px;
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

button {
  padding:8px 12px;
  border-radius:10px;
  border:1px solid var(--border);
  background:#fff;
  cursor:pointer;
}

.toggle {
  display:flex;
  align-items:center;
  gap:6px;
}

.board-wrap {
  margin-top:16px;
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:14px;
  padding:14px;
  overflow-x:auto;
}

.board {
  position:relative;
  min-width:1000px;
  min-height:620px;
}

.tile {
  position:absolute;
  width:var(--tileW);
  height:var(--tileH);
  background:#fff;
  border:2px solid #e5e7eb;
  border-radius:14px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  cursor:pointer;
  user-select:none;
}

.tile.free {
  box-shadow:0 0 0 8px rgba(42,123,111,.18);
}

.tile.blocked {
  opacity:.45;
  cursor:not-allowed;
}

.tile.selected {
  outline:4px solid #2563eb;
}

.tile.hidden {
  visibility:hidden;
}
</style>
</head>

<body>
<div class="wrap">

<header>
  <div class="top">
    <h2>Mahjong Solitaire</h2>
    <div>
      <span id="tilesLeft">144</span> tiles left ·
      <span id="moves">0</span> moves ·
      Time <span id="time">00:00</span>
    </div>
  </div>

  <div class="controls">
    <button onclick="newGame()">New Game</button>
    <button onclick="restart()">Restart</button>
    <button onclick="hint()">Hint</button>
    <button onclick="undo()">Undo</button>

    <label class="toggle">
      <input type="checkbox" onchange="document.body.classList.toggle('large-tiles')">
      Large tiles
    </label>

    <label class="toggle">
      <input type="checkbox" onchange="document.body.classList.toggle('high-contrast')">
      High contrast
    </label>
  </div>
</header>

<div class="board-wrap">
  <div class="board" id="board"></div>
</div>

</div>

<script>
const board = document.getElementById("board");
const tilesLeftEl = document.getElementById("tilesLeft");
const movesEl = document.getElementById("moves");
const timeEl = document.getElementById("time");

let tiles = [];
let selected = null;
let moves = 0;
let startTime = 0;
let timer = null;
let undoStack = [];

/* EXACT 144-POSITION LAYOUT */
const layout = [];
let id = 0;

// Base: 12 x 8 = 96
for (let r=0; r<8; r++) {
  for (let c=0; c<12; c++) {
    layout.push({id:id++, r, c, z:0});
  }
}

// Middle: 8 x 4 = 32
for (let r=2; r<6; r++) {
  for (let c=2; c<10; c++) {
    layout.push({id:id++, r, c, z:1});
  }
}

// Top: 4 x 4 = 16
for (let r=3; r<7; r++) {
  for (let c=4; c<8; c++) {
    layout.push({id:id++, r, c, z:2});
  }
}

// ✅ Total = 96 + 32 + 16 = 144

function startTimer() {
  if (timer) return;
  startTime = Date.now();
  timer = setInterval(() => {
    const t = Math.floor((Date.now() - startTime) / 1000);
    timeEl.textContent =
      String(Math.floor(t/60)).padStart(2,"0") + ":" +
      String(t%60).padStart(2,"0");
  }, 500);
}

function stopTimer() {
  clearInterval(timer);
  timer = null;
}

function buildValues() {
  const vals = [];
  for (let i=1;i<=36;i++) {
    for (let j=0;j<4;j++) vals.push("T"+i);
  }
  return vals.sort(()=>Math.random()-0.5);
}

function newGame() {
  stopTimer();
  moves = 0;
  selected = null;
  undoStack = [];
  board.innerHTML = "";
  tiles = [];

  movesEl.textContent = "0";
  timeEl.textContent = "00:00";

  const values = buildValues();

  layout.forEach((pos, i) => {
    const t = document.createElement("div");
    t.className = "tile";
    t.textContent = values[i];
    t.style.left = (pos.c * (82+6) + pos.z*6) + "px";
    t.style.top = (pos.r * (110+6) - pos.z*6) + "px";
    t.style.zIndex = pos.z * 10;
    t.dataset.value = values[i];
    t.dataset.r = pos.r;
    t.dataset.c = pos.c;
    t.dataset.z = pos.z;
    t.onclick = () => clickTile(t);
    board.appendChild(t);
    tiles.push(t);
  });

  updateFree();
  updateStats();
}

function restart() {
  newGame();
}

function updateStats() {
  tilesLeftEl.textContent = tiles.filter(t=>!t.classList.contains("hidden")).length;
  movesEl.textContent = moves;
}

function isBlocked(tile) {
  const rect = tile.getBoundingClientRect();

  // Blocked from above
  for (const t of tiles) {
    if (
      t === tile ||
      t.classList.contains("hidden") ||
      +t.dataset.z <= +tile.dataset.z
    ) continue;

    const r = t.getBoundingClientRect();
    if (
      r.left < rect.right - 10 &&
      r.right > rect.left + 10 &&
      r.top < rect.bottom - 10 &&
      r.bottom > rect.top + 10
    ) return true;
  }

  // Left and right neighbors
  const left = tiles.some(t =>
    !t.classList.contains("hidden") &&
    +t.dataset.z === +tile.dataset.z &&
    +t.dataset.r === +tile.dataset.r &&
    +t.dataset.c === +tile.dataset.c - 1
  );

  const right = tiles.some(t =>
    !t.classList.contains("hidden") &&
    +t.dataset.z === +tile.dataset.z &&
    +t.dataset.r === +tile.dataset.r &&
    +t.dataset.c === +tile.dataset.c + 1
  );

  return left && right;
}

function updateFree() {
  tiles.forEach(t => {
    if (t.classList.contains("hidden")) return;
    if (isBlocked(t)) {
      t.classList.add("blocked");
      t.classList.remove("free");
    } else {
      t.classList.remove("blocked");
      t.classList.add("free");
    }
  });
}

function clickTile(tile) {
  if (tile.classList.contains("blocked") || tile.classList.contains("hidden")) return;
  startTimer();

  if (!selected) {
    selected = tile;
    tile.classList.add("selected");
    return;
  }

  if (selected === tile) {
    tile.classList.remove("selected");
    selected = null;
    return;
  }

  if (selected.dataset.value === tile.dataset.value) {
    selected.classList.add("hidden");
    tile.classList.add("hidden");
    moves++;
    undoStack.push([selected, tile]);
    updateStats();
  }

  selected.classList.remove("selected");
  selected = null;
  updateFree();
}

function undo() {
  const last = undoStack.pop();
  if (!last) return;
  last.forEach(t => t.classList.remove("hidden"));
  moves--;
  updateStats();
  updateFree();
}

function hint() {
  const free = tiles.filter(t => t.classList.contains("free"));
  for (let i=0;i<free.length;i++) {
    for (let j=i+1;j<free.length;j++) {
      if (free[i].dataset.value === free[j].dataset.value) {
        free[i].classList.add("selected");
        free[j].classList.add("selected");
        setTimeout(()=>{
          free[i].classList.remove("selected");
          free[j].classList.remove("selected");
        },700);
        return;
      }
    }
  }
}

// GitHub Pages render fix
setTimeout(newGame, 60);
</script>

</body>
</html>
