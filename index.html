<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mahjong Solitaire</title>
  <style>
    :root{
      --bg: #f6f7fb;
      --panel: #ffffff;
      --text: #142033;
      --muted: #5c6b82;
      --border: #d9e0ea;
      --shadow: 0 10px 30px rgba(20,32,51,.08);
      --accent: #2a7b6f;
      --danger: #b42318;

      --tileW: 82px;
      --tileH: 110px;
      --gap: 8px;
      --tileRadius: 14px;

      --tileFace: #ffffff;
      --tileEdge: #e7ebf2;
      --tileInk: #0f172a;

      --select: #1f6feb;
      --freeGlow: rgba(42,123,111,.18);
    }

    body.high-contrast{
      --bg: #0b1020;
      --panel: #0f172a;
      --text: #f8fafc;
      --muted: #cbd5e1;
      --border: #22304a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --tileFace: #111a33;
      --tileEdge: #2a3a5d;
      --tileInk: #f8fafc;

      --select: #93c5fd;
      --freeGlow: rgba(147,197,253,.18);
    }

    body.large-tiles{
      --tileW: 96px;
      --tileH: 128px;
      --gap: 10px;
    }

    * { box-sizing: border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    .wrap{
      max-width: 1200px;
      margin: 18px auto 40px;
      padding: 0 14px;
    }

    header{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 14px 14px 10px;
      margin-bottom: 14px;
    }

    .topRow{
      display:flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: space-between;
    }

    .title{
      display:flex;
      align-items: baseline;
      gap: 10px;
      flex-wrap: wrap;
    }
    h1{
      margin:0;
      font-size: 22px;
      letter-spacing: .2px;
    }
    .sub{
      color: var(--muted);
      font-size: 14px;
    }

    .stats{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }
    .pill{
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.02);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 14px;
      color: var(--muted);
    }
    body.high-contrast .pill{ background: rgba(255,255,255,0.03); }

    .btnRow{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }

    button{
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 15px;
      cursor:pointer;
      box-shadow: 0 1px 0 rgba(0,0,0,.04);
    }
    button:hover{ transform: translateY(-1px); }
    button:active{ transform: translateY(0px); }
    button.primary{
      border-color: rgba(42,123,111,.35);
      background: rgba(42,123,111,.08);
    }
    button.danger{
      border-color: rgba(180,35,24,.35);
      background: rgba(180,35,24,.08);
      color: var(--danger);
    }

    .toggles{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
      color: var(--muted);
      font-size: 14px;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 8px 10px;
      background: rgba(0,0,0,0.02);
    }
    body.high-contrast .toggle{ background: rgba(255,255,255,0.03); }
    .toggle input{ transform: scale(1.2); }

    .content{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .boardPanel{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 14px;
      overflow-x: auto;
    }

    .board{
      position: relative;
      min-height: 620px;
      min-width: 1020px;
      margin: 0 auto;
      padding: 10px;
    }

    .tile{
      position:absolute;
      width: var(--tileW);
      height: var(--tileH);
      border-radius: var(--tileRadius);
      background: var(--tileFace);
      border: 2px solid var(--tileEdge);
      box-shadow:
        0 10px 18px rgba(0,0,0,.08),
        inset 0 -3px 0 rgba(0,0,0,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      touch-action: manipulation;
      transition: transform .08s ease, box-shadow .08s ease, outline .08s ease;
    }

    .tile .label{
      font-weight: 800;
      font-size: 22px;
      color: var(--tileInk);
      letter-spacing: .3px;
      text-align:center;
      line-height: 1.05;
      padding: 10px;
    }

    .tile .small{
      display:block;
      font-weight: 700;
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
      letter-spacing: .6px;
      text-transform: uppercase;
    }

    .tile.free{
      box-shadow:
        0 10px 18px rgba(0,0,0,.08),
        0 0 0 10px var(--freeGlow),
        inset 0 -3px 0 rgba(0,0,0,.06);
    }

    .tile.selected{
      outline: 4px solid var(--select);
      outline-offset: 2px;
      transform: translateY(-2px);
    }

    .tile.blocked{
      opacity: .55;
    }

    .footerPanel{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 14px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.45;
    }

    .msg{
      margin-top: 8px;
      font-size: 15px;
      color: var(--text);
      font-weight: 650;
    }

    .note{
      margin-top: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    @media (max-width: 520px){
      .board{ min-width: 920px; }
      button{ width: 100%; }
      .btnRow{ width:100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="topRow">
        <div class="title">
          <h1>Mahjong Solitaire</h1>
          <div class="sub">Match two free tiles to remove them. Clear the board to win.</div>
        </div>

        <div class="stats">
          <div class="pill"><strong id="tilesLeft">144</strong> tiles left</div>
          <div class="pill"><strong id="moves">0</strong> moves</div>
          <div class="pill">Time: <strong id="time">00:00</strong></div>
        </div>

        <div class="toggles">
          <label class="toggle">
            <input id="largeToggle" type="checkbox" />
            Large tiles
          </label>
          <label class="toggle">
            <input id="contrastToggle" type="checkbox" />
            High contrast
          </label>
          <label class="toggle">
            <input id="showFreeToggle" type="checkbox" checked />
            Highlight free
          </label>
        </div>
      </div>

      <div class="btnRow">
        <button class="primary" id="newGameBtn">New Game</button>
        <button id="restartBtn">Restart</button>
        <button id="hintBtn">Hint</button>
        <button id="undoBtn">Undo</button>
        <button id="shuffleBtn">Shuffle Remaining</button>
        <button class="danger" id="helpBtn">How to Play</button>
      </div>

      <div class="msg" id="message">Tip: Start by matching edge tiles that are glowing.</div>
      <div class="note" id="note"></div>
    </header>

    <div class="content">
      <div class="boardPanel">
        <div class="board" id="board" aria-label="Mahjong board"></div>
      </div>

      <div class="footerPanel" id="helpPanel" style="display:none;">
        <strong>How to play</strong>
        <ul>
          <li>Click (or tap) a <strong>free</strong> tile to select it.</li>
          <li>A tile is free when <strong>nothing is on top of it</strong> and it has an <strong>open left or right side</strong>.</li>
          <li>Click a second free tile that matches to remove the pair.</li>
          <li><strong>Flowers</strong> match any other flower. <strong>Seasons</strong> match any other season.</li>
          <li>If you get stuck, use <strong>Hint</strong> or <strong>Shuffle Remaining</strong>.</li>
        </ul>
        This version uses a classic-style stacked layout (two levels) and is designed for easy reading and tapping.
      </div>
    </div>
  </div>

<script>
(() => {
  const boardEl = document.getElementById('board');
  const tilesLeftEl = document.getElementById('tilesLeft');
  const movesEl = document.getElementById('moves');
  const timeEl = document.getElementById('time');
  const messageEl = document.getElementById('message');
  const noteEl = document.getElementById('note');

  const newGameBtn = document.getElementById('newGameBtn');
  const restartBtn = document.getElementById('restartBtn');
  const hintBtn = document.getElementById('hintBtn');
  const undoBtn = document.getElementById('undoBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const helpBtn = document.getElementById('helpBtn');
  const helpPanel = document.getElementById('helpPanel');

  const largeToggle = document.getElementById('largeToggle');
  const contrastToggle = document.getElementById('contrastToggle');
  const showFreeToggle = document.getElementById('showFreeToggle');

  // Layout (144 positions):
  // Base layer: 12 x 10 = 120 tiles (z = 0)
  // Top layer:  6 x 4  = 24  tiles (z = 1), centered on base
  // This gives a true "on-top" blocking behavior, but keeps the game friendly.

  const TILE_W = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tileW'));
  const TILE_H = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tileH'));
  const GAP = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));

  let positions = []; // {id, x, y, z, row, col, layerKey}
  let tiles = [];     // {posId, type, label, group, removed, el}
  let selectedPosId = null;
  let moves = 0;
  let undoStack = [];
  let timer = { running:false, startTs:0, elapsed:0, interval:null };

  // --- Tile set (144 tiles total) ---
  function buildTileSet(){
    const set = [];

    // 3 suits: Bamboo (B), Dots (D), Characters (K) 1-9, 4 copies each
    const suits = [
      {group:'bamboo', prefix:'B', name:'Bamboo'},
      {group:'dots', prefix:'D', name:'Dots'},
      {group:'chars', prefix:'K', name:'Characters'}
    ];

    for (const s of suits){
      for (let n=1; n<=9; n++){
        for (let c=0; c<4; c++){
          set.push({type:`${s.prefix}${n}`, label:`${s.prefix}${n}`, group:s.group, subtitle:s.name});
        }
      }
    }

    // Winds: E S W N, 4 copies each
    const winds = [
      {type:'WE', label:'E', subtitle:'Wind'},
      {type:'WS', label:'S', subtitle:'Wind'},
      {type:'WW', label:'W', subtitle:'Wind'},
      {type:'WN', label:'N', subtitle:'Wind'},
    ];
    for (const w of winds){
      for (let c=0; c<4; c++) set.push({type:w.type, label:w.label, group:'wind', subtitle:w.subtitle});
    }

    // Dragons: Red, Green, White, 4 copies each
    const dragons = [
      {type:'DR', label:'R', subtitle:'Dragon'},
      {type:'DG', label:'G', subtitle:'Dragon'},
      {type:'DW', label:'W', subtitle:'Dragon'},
    ];
    for (const d of dragons){
      for (let c=0; c<4; c++) set.push({type:d.type, label:d.label, group:'dragon', subtitle:d.subtitle});
    }

    // Flowers (F1-4) and Seasons (S1-4): 1 copy each, special matching
    for (let n=1; n<=4; n++) set.push({type:`F${n}`, label:`F${n}`, group:'flower', subtitle:'Flower'});
    for (let n=1; n<=4; n++) set.push({type:`S${n}`, label:`S${n}`, group:'season', subtitle:'Season'});

    return set; // length 144
  }

  // --- Build positions ---
  function buildPositions(){
    const pos = [];
    let id = 0;

    // base 12 x 10
    for (let r=0; r<10; r++){
      for (let c=0; c<12; c++){
        pos.push({
          id: id++,
          row: r,
          col: c,
          z: 0,
          layerKey: 'base'
        });
      }
    }

    // top 6 x 4, centered: offset by (3 cols, 3 rows)
    for (let r=0; r<4; r++){
      for (let c=0; c<6; c++){
        pos.push({
          id: id++,
          row: r + 3,
          col: c + 3,
          z: 1,
          layerKey: 'top'
        });
      }
    }

    // Convert grid coords to pixels
    const w = TILE_W(), h = TILE_H(), g = GAP();
    // Board padding already exists; we lay out with a gentle stagger per layer for a 3D look.
    for (const p of pos){
      const layerShift = p.z * 10; // small offset to suggest stacking
      p.x = p.col * (w + g) + layerShift;
      p.y = p.row * (h + g) - layerShift;
    }

    return pos;
  }

  // --- Helpers ---
  function shuffleArray(arr){
    for (let i=arr.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function formatTime(ms){
    const total = Math.floor(ms/1000);
    const m = String(Math.floor(total/60)).padStart(2,'0');
    const s = String(total%60).padStart(2,'0');
    return `${m}:${s}`;
  }

  function startTimerIfNeeded(){
    if (timer.running) return;
    timer.running = true;
    timer.startTs = Date.now();
    timer.interval = setInterval(() => {
      const now = Date.now();
      const elapsed = timer.elapsed + (now - timer.startTs);
      timeEl.textContent = formatTime(elapsed);
    }, 250);
  }

  function stopTimer(){
    if (!timer.running) return;
    timer.elapsed += (Date.now() - timer.startTs);
    timer.running = false;
    clearInterval(timer.interval);
    timer.interval = null;
  }

  function resetTimer(){
    if (timer.interval) clearInterval(timer.interval);
    timer = { running:false, startTs:0, elapsed:0, interval:null };
    timeEl.textContent = "00:00";
  }

  function setMessage(msg, note=""){
    messageEl.textContent = msg;
    noteEl.textContent = note;
  }

  function matchKey(t){
    // Flowers match any other flower, seasons match any other season.
    if (t.group === 'flower') return 'flower';
    if (t.group === 'season') return 'season';
    return t.type;
  }

  // --- Blocking rules ---
  function getTileByPosId(posId){
    return tiles.find(t => t.posId === posId);
  }

  function isRemoved(posId){
    const t = getTileByPosId(posId);
    return !t || t.removed;
  }

  function rectForPos(pos){
    const w = TILE_W(), h = TILE_H();
    return {x: pos.x, y: pos.y, w, h};
  }

  function overlaps(a, b){
    // axis-aligned overlap
    return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
  }

  function hasTileOnTop(posId){
    const pos = positions.find(p => p.id === posId);
    if (!pos) return false;
    const r = rectForPos(pos);

    // any non-removed tile at higher z that overlaps this tile?
    for (const p2 of positions){
      if (p2.z <= pos.z) continue;
      if (isRemoved(p2.id)) continue;
      const r2 = rectForPos(p2);
      if (overlaps(r, r2)) return true;
    }
    return false;
  }

  function hasNeighborAtSameLayer(posId, side){
    // side = 'left' or 'right'
    const pos = positions.find(p => p.id === posId);
    if (!pos) return false;

    // We treat "blocking" as a tile immediately adjacent in the grid (same z, same row, col +/- 1)
    const targetCol = side === 'left' ? pos.col - 1 : pos.col + 1;
    const neighbor = positions.find(p => p.z === pos.z && p.row === pos.row && p.col === targetCol);
    if (!neighbor) return false;
    return !isRemoved(neighbor.id);
  }

  function isFree(posId){
    if (isRemoved(posId)) return false;
    if (hasTileOnTop(posId)) return false;

    const leftBlocked = hasNeighborAtSameLayer(posId, 'left');
    const rightBlocked = hasNeighborAtSameLayer(posId, 'right');

    // Free if at least one side open
    return (!leftBlocked || !rightBlocked);
  }

  function updateFreeHighlights(){
    for (const t of tiles){
      if (!t.el) continue;
      if (t.removed) continue;

      const free = isFree(t.posId);
      t.el.classList.toggle('free', free && showFreeToggle.checked);
      t.el.classList.toggle('blocked', !free);
    }
  }

  function countRemaining(){
    return tiles.filter(t => !t.removed).length;
  }

  function listFreeTiles(){
    return tiles.filter(t => !t.removed && isFree(t.posId));
  }

  function findAnyMove(){
    const free = listFreeTiles();
    const map = new Map();
    for (const t of free){
      const k = matchKey(t);
      if (!map.has(k)) map.set(k, []);
      map.get(k).push(t);
    }
    for (const [k, list] of map.entries()){
      if (list.length >= 2) return [list[0], list[1]];
    }
    return null;
  }

  // --- Rendering ---
  function clearBoard(){
    boardEl.innerHTML = '';
  }

  function createTileElement(tile, pos){
    const div = document.createElement('div');
    div.className = 'tile';
    div.style.left = pos.x + 'px';
    div.style.top = pos.y + 'px';
    div.style.zIndex = String(100 + pos.z * 10 + pos.row); // stable stacking
    div.setAttribute('role', 'button');
    div.setAttribute('aria-label', `Tile ${tile.label}`);

    const label = document.createElement('div');
    label.className = 'label';
    label.innerHTML = `${tile.label}<span class="small">${tile.subtitle}</span>`;
    div.appendChild(label);

    div.addEventListener('click', () => onTileClick(tile.posId));
    return div;
  }

  function renderAllTiles(){
    clearBoard();
    // Sort by z then y then x to ensure proper DOM order (lower first)
    const posSorted = [...positions].sort((a,b) => (a.z-b.z) || (a.y-b.y) || (a.x-b.x));
    for (const p of posSorted){
      const t = getTileByPosId(p.id);
      if (!t || t.removed) continue;
      const el = createTileElement(t, p);
      t.el = el;
      boardEl.appendChild(el);
    }
    updateFreeHighlights();
    updateStats();
  }

  function updateStats(){
    tilesLeftEl.textContent = String(countRemaining());
    movesEl.textContent = String(moves);
  }

  function clearSelection(){
    if (selectedPosId != null){
      const t = getTileByPosId(selectedPosId);
      if (t && t.el) t.el.classList.remove('selected');
    }
    selectedPosId = null;
  }

  // --- Game logic ---
  function onTileClick(posId){
    const t = getTileByPosId(posId);
    if (!t || t.removed) return;

    // must be free to interact
    if (!isFree(posId)){
      setMessage("That tile isnâ€™t free yet.", "Try one thatâ€™s on an edge or glowing.");
      return;
    }

    startTimerIfNeeded();

    // select first
    if (selectedPosId == null){
      selectedPosId = posId;
      t.el.classList.add('selected');
      setMessage("Now pick a matching free tile.");
      return;
    }

    // clicking same tile clears selection
    if (selectedPosId === posId){
      clearSelection();
      setMessage("Selection cleared.");
      return;
    }

    const a = getTileByPosId(selectedPosId);
    const b = t;

    // both must be free at time of match
    if (!isFree(a.posId) || !isFree(b.posId)){
      clearSelection();
      updateFreeHighlights();
      setMessage("Those tiles changed â€” try again.");
      return;
    }

    // check match
    if (matchKey(a) !== matchKey(b)){
      // keep new selection for convenience
      a.el.classList.remove('selected');
      selectedPosId = b.posId;
      b.el.classList.add('selected');
      setMessage("Not a match.", "Try a tile with the same letter/number (or any Flower/Season).");
      return;
    }

    // Remove pair
    undoStack.push({
      type: 'remove',
      aPosId: a.posId,
      bPosId: b.posId,
      prevMoves: moves
    });

    a.removed = true;
    b.removed = true;
    if (a.el) a.el.remove();
    if (b.el) b.el.remove();

    moves += 1;
    clearSelection();
    updateFreeHighlights();
    updateStats();

    // win?
    if (countRemaining() === 0){
      stopTimer();
      setMessage("You did it! Board cleared ðŸŽ‰", "Start a New Game anytime.");
      return;
    }

    // check if stuck
    const move = findAnyMove();
    if (!move){
      setMessage("No moves found.", "Use Shuffle Remaining or Undo.");
    } else {
      setMessage("Nice match!", "Keep going â€” edges first usually helps.");
    }
  }

  function undo(){
    const last = undoStack.pop();
    if (!last){
      setMessage("Nothing to undo.");
      return;
    }

    if (last.type === 'remove'){
      const a = getTileByPosId(last.aPosId);
      const b = getTileByPosId(last.bPosId);
      if (a){ a.removed = false; }
      if (b){ b.removed = false; }
      moves = last.prevMoves;

      // re-render to restore DOM cleanly
      renderAllTiles();
      clearSelection();
      setMessage("Undid the last move.");
    } else if (last.type === 'shuffle'){
      // restore old types in place
      last.snapshot.forEach(s => {
        const t = getTileByPosId(s.posId);
        if (!t) return;
        t.type = s.type;
        t.label = s.label;
        t.group = s.group;
        t.subtitle = s.subtitle;
      });
      renderAllTiles();
      clearSelection();
      setMessage("Undid the shuffle.");
    }
  }

  function hint(){
    const move = findAnyMove();
    if (!move){
      setMessage("No moves available.", "Try Shuffle Remaining or Undo.");
      return;
    }
    const [a,b] = move;
    // flash both tiles
    const aEl = a.el, bEl = b.el;
    if (!aEl || !bEl) return;

    setMessage("Hereâ€™s a match.", "Those two tiles can be removed.");
    aEl.classList.add('selected');
    bEl.classList.add('selected');
    setTimeout(() => {
      aEl.classList.remove('selected');
      bEl.classList.remove('selected');
      if (selectedPosId != null){
        const cur = getTileByPosId(selectedPosId);
        if (cur && cur.el) cur.el.classList.add('selected');
      }
    }, 650);
  }

  function shuffleRemaining(){
    const remaining = tiles.filter(t => !t.removed);
    if (remaining.length < 2){
      setMessage("Nothing to shuffle.");
      return;
    }

    // snapshot for undo
    const snapshot = remaining.map(t => ({
      posId: t.posId, type: t.type, label: t.label, group: t.group, subtitle: t.subtitle
    }));

    // shuffle the tile TYPES among remaining positions
    const shuffledTypes = shuffleArray(remaining.map(t => ({
      type: t.type, label: t.label, group: t.group, subtitle: t.subtitle
    })));

    remaining.forEach((t, i) => {
      t.type = shuffledTypes[i].type;
      t.label = shuffledTypes[i].label;
      t.group = shuffledTypes[i].group;
      t.subtitle = shuffledTypes[i].subtitle;
    });

    undoStack.push({ type:'shuffle', snapshot });
    renderAllTiles();
    clearSelection();
    setMessage("Shuffled remaining tiles.", "Now look for new matches.");
  }

  function newGame(){
    resetTimer();
    moves = 0;
    undoStack = [];
    selectedPosId = null;

    positions = buildPositions();
    const set = buildTileSet();
    shuffleArray(set);

    tiles = positions.map((p, idx) => ({
      posId: p.id,
      type: set[idx].type,
      label: set[idx].label,
      group: set[idx].group,
      subtitle: set[idx].subtitle,
      removed: false,
      el: null
    }));

    renderAllTiles();
    setMessage("New game ready.", "Tip: Start with glowing edge tiles.");
    const move = findAnyMove();
    if (!move){
      setMessage("This shuffle has no opening moves.", "Click Shuffle Remaining to fix it.");
    }
  }

  function restart(){
    // Restart keeps the same tile layout assignment,
